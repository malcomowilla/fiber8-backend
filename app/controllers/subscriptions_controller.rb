class SubscriptionsController < ApplicationController
  # before_action :set_subscription, only: %i[ show edit update destroy ]

  # GET /subscriptions or /subscriptions.json

set_current_tenant_through_filter

before_action :set_current_tenant

load_and_authorize_resource

  
    
def set_current_tenant

  host = request.headers['X-Subdomain']
  @account = Account.find_by(subdomain: host)
   @current_account=ActsAsTenant.current_tenant 
  EmailConfiguration.configure(@current_account, ENV['SYSTEM_ADMIN_EMAIL'])

  # set_current_tenant(@account)
rescue ActiveRecord::RecordNotFound
  render json: { error: 'Invalid tenant' }, status: :not_found

  
end




def last_seen
  subscriptions = Subscription.all

  data = subscriptions.map do |subscription|
    
    radacct = RadAcct.where(username: subscription.ppoe_username)
    .order(acctupdatetime: :desc, acctstoptime: :desc)
                     .first

Rails.logger.info "radacct: #{radacct}"
    if radacct
      if radacct.acctstoptime.blank?
        {
          id: subscription.id,
          ppoe_username: subscription.ppoe_username,
          status: "online",
          last_seen: radacct.acctupdatetime.strftime("%B %d, %Y at %I:%M %p")
        }
      else
        {
          id: subscription.id,
          ppoe_username: subscription.ppoe_username,
          status: "offline",
          last_seen: radacct.acctstoptime.strftime("%B %d, %Y at %I:%M %p")
        }
      end
    else
      {
        id: subscription.id,
        ppoe_username: subscription.ppoe_username,
        status: "never connected",
        last_seen: nil
      }
    end
  end

  render json: data
end







  def index
    @subscriptions = Subscription.all
    render json: @subscriptions
  end





  def get_ips
    # Step 1: Get the network details
    network = IpNetwork.find_by(title: params[:network_name])
  
    if network.nil?
      render json: { error: "Network not found" }, status: 404 and return
    end
  
    # Step 2: Parse the network and generate the range
    cidr = "#{network.network}/#{network.subnet_mask}"
    network_range = IPAddr.new(cidr).to_range.to_a
  
    # Step 3: Filter out reserved IPs
    reserved_ips = [
      network_range.first,  # Network address (.0)
      network_range.last,   # Broadcast address (.255)
      IPAddr.new(network_range.first.to_i + 1, Socket::AF_INET)  # Typically .1 (gateway)
    ]
  
    available_ips = network_range - reserved_ips
  
    # Step 4: Exclude already used IPs
    used_ips = Subscription.pluck(:ip_address).compact.map { |ip| IPAddr.new(ip) }
    available_ips -= used_ips
  
    # Step 5: Select a small, unique set of IPs (e.g., 5 IPs)
    limited_ips = available_ips.sample(5) # You can change 5 to whatever small number you want
  
    if limited_ips.empty?
      render json: { error: "No available IPs in the network" }, status: 404 and return
    end
  
    # Step 6: Return the selected IPs
    render json: limited_ips.map(&:to_s)
  end
  

  # POST /subscriptions or /subscriptions.json
  def create


    if params[:subscription][:ppoe_username].blank? || params[:subscription][:ppoe_password].blank?
      render json: { error: "Username and password are required" }, status: :unprocessable_entity
      return
    end
  
    # Check uniqueness manually
    if Subscription.exists?(ppoe_username: params[:subscription][:ppoe_username])
      render json: { error: "Username already taken" }, status: :unprocessable_entity
      return
    end
    use_autogenerated_number_as_ppoe_password = ActsAsTenant.current_tenant.subscriber_setting.use_autogenerated_number_as_ppoe_password
    use_autogenerated_number_as_ppoe_username = ActsAsTenant.current_tenant.subscriber_setting.use_autogenerated_number_as_ppoe_username
   

    if !use_autogenerated_number_as_ppoe_password && !use_autogenerated_number_as_ppoe_username
      if Subscription.exists?(ppoe_username: params[:subscription][:ppoe_username])
        render json: { error: "ppoe username already exists" }, status: :unprocessable_entity
        return
        
      end
    end
    
    @subscription = Subscription.create(
      
    # params[:subscription][:name],
    package: params[:subscription][:package_name],
    phone_number: params[:subscription][:phone_number],
  status:  params[:subscription][:status],
  ip_address: params[:subscription][:ip_address],
  ppoe_username:  params[:subscription][:ppoe_username],
  ppoe_password:  params[:subscription][:ppoe_password],
  type:  params[:subscription][:type],
  network_name: params[:subscription][:network_name],
  # mac_address: params[:subscription][:mac_address],
  validity_period_units: params[:subscription][:validity_period_units],
  validity:  params[:subscription][:validity]

    )

    create_pppoe_credentials_radius(params[:subscription][:ppoe_password], 
    params[:subscription][:ppoe_username], params[:subscription][:package_name],  params[:subscription][:ip_address])
   
    
    calculate_expiration(@subscription)
      if @subscription.save
         render json: @subscription, status: :created
      else
     render json: @subscription.errors, status: :unprocessable_entity 
      end
    

  end

  
  def destroy
    @subscription = set_subscription
  
    if @subscription.nil?
      return render json: { error: "Subscription not found" }, status: :not_found
    end
  
    ActiveRecord::Base.transaction do
      # ✅ Delete FreeRADIUS records first
      RadCheck.where(username: @subscription.ppoe_username).destroy_all
      RadGroupCheck.where(groupname: @subscription.ppoe_username).destroy_all
      RadGroupCheck.where(groupname: @subscription.ppoe_password).destroy_all

      RadUserGroup.where(username: @subscription.ppoe_username).destroy_all
      RadUserGroup.where(username: @subscription.ppoe_password).destroy_all
 
  
  #     # ✅ Delete the HotspotVoucher record
      @subscription.destroy!
  
      render json: { message: "subscription deleted successfully" }, status: :ok
    end
  rescue => e
    render json: { error: "Failed to delete subscription: #{e.message}" }, status: :unprocessable_entity
  end


  def update
    @subscription = set_subscription
    if params[:subscription][:ppoe_username].blank? || params[:subscription][:ppoe_password].blank?
      render json: { error: "Username and password are required" }, status: :unprocessable_entity
      return
    end
  
    # Check uniqueness manually
    if Subscription.where(ppoe_username: params[:subscription][:ppoe_username])
      .where.not(id: @subscription.id)
      .exists?
      render json: { error: "Username already taken" }, status: :unprocessable_entity
      return
    end
    if @subscription.update(subscription_params)
      calculate_expiration(@subscription)
      create_pppoe_credentials_radius(params[:subscription][:ppoe_password], 
      params[:subscription][:ppoe_username], params[:subscription][:package_name],  params[:subscription][:ip_address])
     
      render json: @subscription, status: :ok
    else
      render json: @subscription.errors, status: :unprocessable_entity
    end
  end
  private
    # Use callbacks to share common setup or constraints between actions.
    def set_subscription
      @subscription = Subscription.find_by(id: params[:id])
    end




    def create_pppoe_credentials_radius(pppoe_password, pppoe_username, package, pppoe_ip)

      pppoe_package = "pppoe_#{package.parameterize(separator: '_')}"

  use_autogenerated_number_as_ppoe_password = ActsAsTenant.current_tenant.subscriber_setting.use_autogenerated_number_as_ppoe_password
  use_autogenerated_number_as_ppoe_username = ActsAsTenant.current_tenant.subscriber_setting.use_autogenerated_number_as_ppoe_username
 
  
  

      # Create or update RadCheck (password)
      rad_check = RadCheck.find_or_initialize_by(username: pppoe_username, radiusattribute: 'Cleartext-Password')
      rad_check.assign_attributes(op: ':=', value: pppoe_password)
      rad_check.save!

      rad_reply = RadReply.find_or_initialize_by(username: pppoe_username, radiusattribute: 'Framed-IP-Address')
      rad_reply.assign_attributes(op: '=', value: pppoe_ip)
      rad_reply.save!
    
      # Create or update RadUserGroup (package)
      use_autogenerated_number_as_ppoe_username && user_group = RadUserGroup.find_or_initialize_by(username: pppoe_username, groupname: pppoe_package)
      use_autogenerated_number_as_ppoe_password && user_group = RadUserGroup.find_or_initialize_by(username: pppoe_password, groupname: pppoe_package)


      if !use_autogenerated_number_as_ppoe_password && !use_autogenerated_number_as_ppoe_username
        user_group = RadUserGroup.find_or_initialize_by(username: pppoe_username, groupname: pppoe_package)
      end

      user_group.assign_attributes(groupname: pppoe_package, priority: 1)
      user_group.save!
    
      # Get package validity
      pkg = Package.find_by(name: package)
      validity_period_units = pkg&.validity_period_units
      validity = pkg&.validity
    
      expiration_time = case validity_period_units
                        when 'days' then Time.current + validity.days
                        when 'hours' then Time.current + validity.hours
                        when 'minutes' then Time.current + validity.minutes
                        end&.strftime("%d %b %Y %H:%M:%S")
    
      # Create or update Expiration in RadGroupCheck
      if expiration_time


        use_autogenerated_number_as_ppoe_username && user_group = RadUserGroup.find_or_initialize_by(username: pppoe_username, groupname: pppoe_package)
        use_autogenerated_number_as_ppoe_password && user_group = RadUserGroup.find_or_initialize_by(username: pppoe_password, groupname: pppoe_package)
  

        use_autogenerated_number_as_ppoe_username && user_group = RadUserGroup.find_or_initialize_by(username: pppoe_username, groupname: pppoe_package)
        use_autogenerated_number_as_ppoe_password && user_group = RadUserGroup.find_or_initialize_by(username: pppoe_password, groupname: pppoe_package)
  
  

if use_autogenerated_number_as_ppoe_username
  expiration_check = RadGroupCheck.find_or_initialize_by(groupname: pppoe_username, radiusattribute: 'Expiration')
  expiration_check.assign_attributes(op: ':=', value: expiration_time)
  expiration_check.save!
end



if use_autogenerated_number_as_ppoe_password
  expiration_check = RadGroupCheck.find_or_initialize_by(groupname: pppoe_password, radiusattribute: 'Expiration')
  expiration_check.assign_attributes(op: ':=', value: expiration_time)
  expiration_check.save!
end
  
        if !use_autogenerated_number_as_ppoe_password && !use_autogenerated_number_as_ppoe_username
          expiration_check = RadGroupCheck.find_or_initialize_by(groupname: pppoe_username, radiusattribute: 'Expiration')
          expiration_check.assign_attributes(op: ':=', value: expiration_time)
          expiration_check.save!
        end



       
      end
      
      
      
      end




    
    def calculate_expiration(subscription)
      return nil unless subscription.validity.present? && subscription.validity_period_units.present?
    
      validity = subscription.validity.to_i
    
      # Calculate expiration time
      expiration_time = case subscription.validity_period_units.downcase
                        when 'days'
                          Time.current + validity.days
                        when 'hours'
                          Time.current + validity.hours
                        when 'minutes'
                          Time.current + validity.minutes
                        else
                          nil
                        end
    
      # If expiration was calculated, update the subscription
      if expiration_time
        subscription.update(expiry: expiration_time)
        formatted_expiry = expiration_time.strftime("%B %d, %Y at %I:%M %p")
      else
        formatted_expiry = "unknown"
      end
    
      # Return formatted expiry
      {
        expiry: formatted_expiry
      }
    end
    






    # Only allow a list of trusted parameters through.
    def subscription_params
      params.require(:subscription).permit(:name, :phone_number, :package, :status, 
      :last_subscribed, :expiry, :ip_address,
       :ppoe_username, :ppoe_password, :type, :network_name, :mac_address, :validity_period_units, :validity)
    end

   

end
