class SubscribersController < ApplicationController
  # before_action :set_subscriber, only: %i[ show edit update destroy ]
  rescue_from ActiveRecord::RecordNotFound, with: :subscriber_not_found_response
rescue_from  ActiveRecord::RecordInvalid, with: :subscriber_invalid

  # load_and_authorize_resource except: [:import]
load_and_authorize_resource 
require 'csv'

set_current_tenant_through_filter

before_action :set_tenant







def import
  file = params[:file]
  return render json: { error: 'No file uploaded' }, status: :bad_request unless file

  tenant_settings = ActsAsTenant.current_tenant.subscriber_setting
use_autogenerated_number_as_ppoe_username = ActsAsTenant.current_tenant.subscriber_setting.use_autogenerated_number_as_ppoe_username
   use_autogenerated_number_as_ppoe_password = ActsAsTenant.current_tenant.subscriber_setting.use_autogenerated_number_as_ppoe_password
   use_radius = ActsAsTenant.current_tenant.router_setting.use_radius

  prefix = tenant_settings.prefix
  minimum_digits = tenant_settings.minimum_digits
  
  if use_radius


  if !prefix || !minimum_digits
    render json: { error: 'Prefix and Minimum Digits not found' }, status: :not_found

  end

  begin
    subscribers = []

    file_content = File.read(file.path).encode('UTF-8', 'binary', invalid: :replace, undef: :replace, replace: '')
    file_content.sub!("\uFEFF", '')  # Remove BOM if present

    CSV.parse(file_content, headers: true) do |row|
      normalized_row = row.to_h.transform_keys { |key| key.downcase.strip.gsub(/\s+/, '_') }  # Normalize column names
      normalized_row.delete("action")  # Ignore "action" column
      normalized_row.delete("id")
      subscriber = Subscriber.new(normalized_row)


      "#{prefix}#{subscriber.sequence_number.to_s.rjust(minimum_digits.to_i, '0')}" if prefix && minimum_digits

      # ✅ Assign auto-generated number as username & password if enabled
      subscriber.ppoe_username = subscriber.ref_no if use_autogenerated_number_as_ppoe_username
      subscriber.ppoe_password = subscriber.ref_no if use_autogenerated_number_as_ppoe_password

if subscriber.ppoe_username.nil? || subscriber.ppoe_password.nil?
  mikrotik_user_id = fetch_subscriber_id_from_mikrotik_import(subscriber.ref_no, subscriber.ref_no) 

  subscriber.mikrotik_user_id = mikrotik_user_id if mikrotik_user_id
else
  mikrotik_user_id = fetch_subscriber_id_from_mikrotik_import(subscriber.ppoe_username, subscriber.ppoe_password) 

  subscriber.mikrotik_user_id = mikrotik_user_id if mikrotik_user_id
end


     

      
    

      subscribers << subscriber
    end

    if subscribers.all?(&:valid?)
      Subscriber.import(subscribers)
      render json: { message: 'Subscribers imported successfully' }, status: :ok
    else
      errors = subscribers.reject(&:valid?).map { |s| s.errors.full_messages }
      render json: { error: 'Validation failed', details: errors }, status: :unprocessable_entity
    end
  rescue CSV::MalformedCSVError => e
    render json: { error: "CSV format error: #{e.message}" }, status: :unprocessable_entity
  rescue => e
    render json: { error: e.message }, status: :unprocessable_entity
  end
  else

  if !prefix || !minimum_digits
    render json: { error: 'Prefix and Minimum Digits not found' }, status: :not_found



  end

  begin
    subscribers = []

    file_content = File.read(file.path).encode('UTF-8', 'binary', invalid: :replace, undef: :replace, replace: '')
    file_content.sub!("\uFEFF", '')  # Remove BOM if present

    CSV.parse(file_content, headers: true) do |row|
      normalized_row = row.to_h.transform_keys { |key| key.downcase.strip.gsub(/\s+/, '_') }  # Normalize column names
      normalized_row.delete("action")  # Ignore "action" column
      normalized_row.delete("id")
      subscriber = Subscriber.new(normalized_row)


      "#{prefix}#{subscriber.sequence_number.to_s.rjust(minimum_digits.to_i, '0')}" if prefix && minimum_digits

      # ✅ Assign auto-generated number as username & password if enabled
      subscriber.ppoe_username = subscriber.ref_no if use_autogenerated_number_as_ppoe_username
      subscriber.ppoe_password = subscriber.ref_no if use_autogenerated_number_as_ppoe_password

 if subscriber.ppoe_username.nil? || subscriber.ppoe_password.nil?
  ppoe_secret_id = fetch_ppoe_secrets_from_mikrotik_import(subscriber.ref_no, subscriber.ref_no, subscriber.package_name)
  subscriber.ppoe_secrets_id = ppoe_secret_id if ppoe_secret_id

else
  
  ppoe_secret_id = fetch_ppoe_secrets_from_mikrotik_import(subscriber.ppoe_password, subscriber.ppoe_username,
   subscriber.package_name)

  subscriber.ppoe_secrets_id = ppoe_secret_id if ppoe_secret_id

end
      


    

      subscribers << subscriber
    end

    if subscribers.all?(&:valid?)
      Subscriber.import(subscribers)
      render json: { message: 'Subscribers imported successfully' }, status: :ok
    else
      errors = subscribers.reject(&:valid?).map { |s| s.errors.full_messages }
      render json: { error: 'Validation failed', details: errors }, status: :unprocessable_entity
    end
  rescue CSV::MalformedCSVError => e
    render json: { error: "CSV format error: #{e.message}" }, status: :unprocessable_entity
  rescue => e
    render json: { error: e.message }, status: :unprocessable_entity
  end
  end
    


end






def set_tenant

  host = request.headers['X-Subdomain']
  @account = Account.find_by(subdomain: host)
  ActsAsTenant.current_tenant = @account
  set_current_tenant(@account)
  EmailConfiguration.configure(@account, ENV['SYSTEM_ADMIN_EMAIL'])

  # set_current_tenant(@account)
rescue ActiveRecord::RecordNotFound
  render json: { error: 'Invalid tenant' }, status: :not_found

  
end








#
  # GET /subscribers or /subscribers.json
  def index
    @subscribers = Subscriber.all
    render json: @subscribers, each_serializer: SubscriberSerializer
  end





  def total_subscribers
    # current_account = ActsAsTenant.current_tenant
    total_subscribers = Subscriber.count
    render json: { total_subscribers: total_subscribers }
  end
  
  # POST /subscribers or /subscribers.json
#   def create
#     @subscriber = Subscriber.new(subscriber_params)
#     prefix = ActsAsTenant.current_tenant.subscriber_setting.prefix
#     minimum_digits = ActsAsTenant.current_tenant.subscriber_setting.minimum_digits

#     use_autogenerated_number_as_ppoe_username = ActsAsTenant.current_tenant.subscriber_setting.use_autogenerated_number_as_ppoe_username
#     use_autogenerated_number_as_ppoe_password = ActsAsTenant.current_tenant.subscriber_setting.use_autogenerated_number_as_ppoe_password


    

#     use_radius = ActsAsTenant.current_tenant.router_setting.use_radius


# if use_radius == true || use_radius == 'true'
#   subscriber_id = fetch_subscriber_id_from_mikrotik(@subscriber.ppoe_username)

#   if @subscriber.save
#     Rails.logger.info "Subscriber saved: #{@subscriber.inspect}"

#     auto_generated_no = @subscriber.ref_no = "#{prefix}#{@subscriber.sequence_number.to_s.rjust(minimum_digits.to_i, '0')}" if prefix && minimum_digits


#     if use_autogenerated_number_as_ppoe_username == true
      
#       @subscriber.update(ppoe_username: auto_generated_no)
#     end

#     if use_autogenerated_number_as_ppoe_password == true
#       @subscriber.update(ppoe_password: auto_generated_no)
#     end

#     @subscriber.update(ref_no: auto_generated_no)
   
    
#     if subscriber_id
#       @subscriber.update(mikrotik_user_id: subscriber_id)
#       render json: @subscriber, status: :created

#     else
#       Rails.logger.error 'Failed to fetch subscriber_id from mikrotik'
#       render json: { error: 'Failed to create subscriber' }, status: :unprocessable_entity
#       return
#     end

#   else
#     render json: { error: 'Subscriber Already Created' }, status: :unprocessable_entity
#   end
# else



#   if @subscriber.save
#     auto_generated_no = @subscriber.ref_no = "#{prefix}#{@subscriber.sequence_number.to_s.rjust(minimum_digits.to_i, '0')}" if prefix && minimum_digits

#     Rails.logger.info "Subscriber saved: #{@subscriber.inspect}"
#     ppoe_secrets_id = fetch_ppoe_secrets_from_mikrotik(auto_generated_no, auto_generated_no)



# # auto_generated_no = @subscriber.ref_no = "#{prefix}#{@subscriber.sequence_number.to_s.rjust(minimum_digits.to_i, '0')}" if prefix && minimum_digits
#     if use_autogenerated_number_as_ppoe_username == true
      
#       @subscriber.update(ppoe_username: auto_generated_no)
#     end

#     # ppoe_secrets_id = fetch_ppoe_secrets_from_mikrotik(@subscriber.ppoe_password, @subscriber.ppoe_username )

#     if use_autogenerated_number_as_ppoe_password == true
#       @subscriber.update(ppoe_password: auto_generated_no)
#     end

#     @subscriber.update(ref_no: auto_generated_no)
   
    
#     if ppoe_secrets_id
#       @subscriber.update(ppoe_secrets_id: ppoe_secrets_id)
#       render json: @subscriber, status: :created

#     else
#       Rails.logger.error 'Failed to fetch subscriber_id from mikrotik'
#       render json: { error: 'Failed to fetch ppoe secrets id from mikrotik' }, status: :unprocessable_entity
#       return
#     end

#   else
#     render json: { error: @subscriber.errors.full_messages }, status: :unprocessable_entity
#   end



# end
  


#   end
  
def create
  @subscriber = Subscriber.new(subscriber_params)
    prefix = ActsAsTenant.current_tenant.subscriber_setting.prefix
    minimum_digits = ActsAsTenant.current_tenant.subscriber_setting.minimum_digits

    use_autogenerated_number_as_ppoe_username = ActsAsTenant.current_tenant.subscriber_setting.use_autogenerated_number_as_ppoe_username
    use_autogenerated_number_as_ppoe_password = ActsAsTenant.current_tenant.subscriber_setting.use_autogenerated_number_as_ppoe_password


  if @subscriber.save
    Rails.logger.info "Subscriber saved: #{@subscriber.inspect}"

    auto_generated_no = @subscriber.ref_no = "#{prefix}#{@subscriber.sequence_number.to_s.rjust(minimum_digits.to_i, '0')}" if prefix && minimum_digits
    
    if use_autogenerated_number_as_ppoe_username == true
      
      @subscriber.update(ppoe_username: auto_generated_no)
    end

    if use_autogenerated_number_as_ppoe_password == true
      @subscriber.update(ppoe_password: auto_generated_no)
    end
    calculate_expiration(params[:package_name], @subscriber)
    create_ppoe_us_and_pass_radcheck(params[:ppoe_username], params[:ppoe_password], params[:package_name])

    @subscriber.update(ref_no: auto_generated_no)


  else
    render json: { error: @subscriber.errors.full_messages }, status: :unprocessable_entity


  end



end







def get_general_settings
  
  @account = Account.find_by(domain: request.domain)

  if @account.respond_to?(:prefix_and_digits)
    Rails.logger.info "prefix_and_digits association exists"
    @prefix = @account.prefix_and_digits.all
    # render json: @prefix
    render json: @prefix,  context: {check_update_username: params[:check_update_username], 
    check_update_password: params[:check_update_password] , welcome_back_message: params[:welcome_back_message],
    router_name: params[:router_name]
  }

  # render json: @prefix, status: :created, context: {
  #   check_update_username: ActiveModel::Type::Boolean.new.cast(params[:check_update_username]),
  #   check_update_password: ActiveModel::Type::Boolean.new.cast(params[:check_update_password])
  # }
  else
    Rails.logger.error "prefix_and_digits association does not exist"
    render json: { error: "Account does not have a 'prefix_and_digits' relationship" }, status: :unprocessable_entity
  end
  
end


  def update_general_settings
    @account = Account.find_by(domain: request.domain)
    if @account.respond_to?(:prefix_and_digits)
      Rails.logger.info "prefix_and_digits association exists"
      @prefix = @account.prefix_and_digits.first_or_initialize(prefix: params[:prefix] , minimum_digits: params[:minimum_digits])
      @prefix.update(prefix: params[:prefix] , minimum_digits: params[:minimum_digits])
    @prefix.user = current_user


      if @prefix.save
        
        Rails.logger.info "PrefixAndDigit created successfully: #{@prefix.inspect}"
        render json: @prefix, status: :created, serializer: PrefixDigitsSerializer,context: {check_update_username:
         params[:check_update_username],  welcome_back_message: params[:welcome_back_message],
        check_update_password: params[:check_update_password], router_name: params[:router_name] }
      else
        Rails.logger.error "Failed to create PrefixAndDigit: #{@prefix.errors.full_messages.join(", ")}"
        render json: @prefix.errors, status: :unprocessable_entity
      end
    else
      Rails.logger.error "prefix_and_digits association does not exist"
      render json: { error: "Account does not have a 'prefix_and_digits' relationship" }, status: :unprocessable_entity
    end
    



    # if @account.respond_to?(:subscribers)
    #   Rails.logger.info "subscribers association exists"

    #   if params[:check_update_username] == true && params[:check_update_password] == true

    #     render json: {message: 'settings updated'}, serializer: PrefixDigitsSerializer
    #       end
        
          


    #         else
    #           render json: { error: "Account does not have a 'subscribers' relationship" }, status: :unprocessable_entity

    # end
   
  end


  # def update_prefix_and_minimum_no_digits
  #   update(subscriber_prefix_prefered_no_digits_params)
  # end


  # PATCH/PUT /subscribers/1 or /subscribers/1.json
  def update
    found_subscriber = set_subscriber

    use_radius = ActsAsTenant.current_tenant.router_setting.use_radius
    
    unless found_subscriber
      return render json: { error: "Package not found" }, status: :not_found
    end
  
  
    if use_radius
      router_name = params[:router_name]
      nas_router = NasRouter.find_by(name: router_name)
    
      unless nas_router
        return render json: { error: "Router not found" }, status: :not_found
      end
    
      router_ip_address = nas_router.ip_address
      router_password = nas_router.password
        router_username = nas_router.username
    
      ppoe_secrets_id = found_subscriber.ppoe_secrets_id
      mikrotik_user_id = found_subscriber.mikrotik_user_id
    
      unless mikrotik_user_id.present?
        return render json: { error: "mikrotik_user_id id missing in package" }, status: :unprocessable_entity
      end 
    
      begin



        request_body2={
          name: params[:ppoe_username],
          password:   params[:ppoe_password] 
        }

        uri = URI("http://#{router_ip_address}/rest/user-manager/user/#{mikrotik_user_id}")
    
        request = Net::HTTP::Patch.new(uri)
    
        request.basic_auth(router_username, router_password)
        request.body = request_body2.to_json
        request.content_type = 'application/json'
        response = Net::HTTP.start(uri.hostname, uri.port, open_timeout: 10, read_timeout: 10) { |http| http.request(request) }
    
        if response.is_a?(Net::HTTPSuccess) 
    
          found_subscriber.update(subscriber_params)
        render json: found_subscriber, status: :ok
        else
          error_message = "Failed to delete usermanager user - #{response.code} #{response.message}"
          render json: { error: error_message }, status: :unprocessable_entity
        end
    
      rescue Net::OpenTimeout, Net::ReadTimeout
        render json: { error: "Request timed out while connecting to the router. Please check if the router is online." }, status: :gateway_timeout
      rescue Errno::ECONNREFUSED
        render json: { error: "Failed to connect to the router at #{router_ip_address}. Connection refused." }, status: :bad_gateway
      rescue StandardError => e
        render json: { error: "An unexpected error occurred: #{e.message}" }, status: :internal_server_error
      end
      
    else
  
    router_name = params[:router_name]
    nas_router = NasRouter.find_by(name: router_name)
  


     req_body = {
                                
                                "password" => params[:ppoe_password],
                            "name" => params[:ppoe_username],
                            "profile" => params[:package_name],
                           
                              }
    unless nas_router
      return render json: { error: "Router not found" }, status: :not_found
    end
  
    router_ip_address = nas_router.ip_address
    router_password = nas_router.password
    router_username = nas_router.username
  
    ppoe_secrets_id = found_subscriber.ppoe_secrets_id
  
    unless ppoe_secrets_id.present?
      return render json: { error: "secrets id missing in package" }, status: :unprocessable_entity
    end
  
    begin
      uri = URI("http://#{router_ip_address}/rest/ppp/secret/#{ppoe_secrets_id}")
  
      request = Net::HTTP::Patch.new(uri)
  
      request.basic_auth(router_username, router_password)

      request['Content-Type'] = 'application/json'

      request.body = req_body.to_json
      response = Net::HTTP.start(uri.hostname, uri.port){|http| http.request(request)}
  
      if response.is_a?(Net::HTTPSuccess) 
  
        found_subscriber.update(subscriber_params)
        render json: found_subscriber, status: :ok
      else
        error_message = "Failed to update: Ppp  secrets - #{response.code} #{response.message}"
        render json: { error: error_message }, status: :unprocessable_entity
      end
  
    rescue Net::OpenTimeout, Net::ReadTimeout
      render json: { error: "Request timed out while connecting to the router. Please check if the router is online." }, status: :gateway_timeout
    rescue Errno::ECONNREFUSED
      render json: { error: "Failed to connect to the router at #{router_ip_address}. Connection refused." }, status: :bad_gateway
    rescue StandardError => e
      render json: { error: "An unexpected error occurred: #{e.message}" }, status: :internal_server_error
    end
    end
  

  end




#   {
#   "caller-id": "any",
#   "comment": "any",
#   "copy-from": "any",
#   "disabled": "any",
#   "ipv6-routes": "any",
#   "limit-bytes-in": "any",
#   "limit-bytes-out": "any",
#   "local-address": "any",
#   "name": "any",
#   "password": "any",
#   "profile": "any",
#   "remote-address": "any",
#   "remote-ipv6-prefix": "any",
#   "routes": "any",
#   "service": "any",
#   ".proplist": "any",
#   ".query": "array"
# }

  # /ppp/secret/add



def fetch_ppoe_secrets_from_mikrotik(ppoe_password, ppoe_username)
  use_autogenerated_number_as_ppoe_password = ActsAsTenant.current_tenant.subscriber_setting.use_autogenerated_number_as_ppoe_password
  use_autogenerated_number_as_ppoe_username = ActsAsTenant.current_tenant.subscriber_setting.use_autogenerated_number_as_ppoe_username

  ppoe_password = use_autogenerated_number_as_ppoe_password ? ppoe_password : params[:ppoe_password]
      router_name = params[:router_name]
      package_name = params[:package_name]
    ppoe_username = use_autogenerated_number_as_ppoe_username ? ppoe_username : params[:ppoe_username]

    
      nas_router = NasRouter.find_by(name: router_name)
    if nas_router
      router_ip_address = nas_router.ip_address
        router_password = nas_router.password
       router_username = nas_router.username
    
    else
    
    Rails.logger.info 'router not found'
    end




    request_body={
     
  
    # "caller-id": "any",
    # "comment": "any",
    # "local-address": "any",
    "name": "#{ppoe_username}",
    "password": "#{ppoe_password}",
    "profile": "#{package_name}",
    # "remote-address": "any",
    "service": "pppoe",
    }


    uri = URI("http://#{router_ip_address}/rest/ppp/secret/add")
    request = Net::HTTP::Post.new(uri)

    request.basic_auth router_username, router_password
    request.body = request_body.to_json
    request['Content-Type'] = 'application/json'



    response = Net::HTTP.start(uri.hostname, uri.port) do |http|
      http.request(request)
    end

    if response.is_a?(Net::HTTPSuccess)
      
      data = JSON.parse(response.body)
      return data['ret']


    else
      Rails.logger.info "Failed to  create subscriber: #{response.code} - #{response.message}"
    end
end


   





  def fetch_ppoe_secrets_from_mikrotik_import(ppoe_password, ppoe_username, package_name)
  
        router_name = params[:router_name]
  
      
        nas_router = NasRouter.find_by(name: router_name)
      if nas_router
        router_ip_address = nas_router.ip_address
          router_password = nas_router.password
         router_username = nas_router.username
      
      else
      
      Rails.logger.info 'router not found'
      end
  
  
  
  
      request_body={
       
    
      # "caller-id": "any",
      # "comment": "any",
      # "local-address": "any",
      "name": "#{ppoe_username}",
      "password": "#{ppoe_password}",
      "profile": "#{package_name}",
      # "remote-address": "any",
      "service": "pppoe",
      }
  
  
      uri = URI("http://#{router_ip_address}/rest/ppp/secret/add")
      request = Net::HTTP::Post.new(uri)
  
      request.basic_auth router_username, router_password
      request.body = request_body.to_json
      request['Content-Type'] = 'application/json'
  
  
  
      response = Net::HTTP.start(uri.hostname, uri.port) do |http|
        http.request(request)
      end
  
      if response.is_a?(Net::HTTPSuccess)
        
        data = JSON.parse(response.body)
        return data['ret']
  
  
      else
        Rails.logger.info "Failed to  create subscriber: #{response.code} - #{response.message}"
      end
  end
  
  
      def fetch_subscriber_id_from_mikrotik(ppoe_username) 
  
        # name = subscriber_params[:name]
        password = subscriber_params[:ppoe_password]
        router_name = params[:router_name]
      # ppoe_username = subscriber_params[:ppoe_username]
        nas_router = NasRouter.find_by(name: router_name)
      if nas_router
        router_ip_address = nas_router.ip_address
          router_password = nas_router.password
         router_username = nas_router.username
      
      else
      
  Rails.logger.info 'router not found'
      end
  
  
  
  
      request_body={
        name: ppoe_username,
        password:   password ,
      }
  
  
      uri = URI("http://#{router_ip_address}/rest/user-manager/user/add")
      request = Net::HTTP::Post.new(uri)
  
      request.basic_auth router_username, router_password
      request.body = request_body.to_json
      request['Content-Type'] = 'application/json'
  
  
  
      response = Net::HTTP.start(uri.hostname, uri.port) do |http|
        http.request(request)
      end
  
      if response.is_a?(Net::HTTPSuccess)
        
        data = JSON.parse(response.body)
        return data['ret']
  
  
      else
        Rails.logger.info "Failed to  create subscriber: #{response.code} - #{response.message}"
      end
  
  
      
  
  
    end





    def fetch_subscriber_id_from_mikrotik_import(ppoe_username, ppoe_password) 
  
      # name = subscriber_params[:name]
      router_name = params[:router_name]
    # ppoe_username = subscriber_params[:ppoe_username]
      nas_router = NasRouter.find_by(name: router_name)
    if nas_router
      router_ip_address = nas_router.ip_address
        router_password = nas_router.password
       router_username = nas_router.username
    
    else
    
Rails.logger.info 'router not found'
    end




    request_body={
      name: ppoe_username,
      password:   ppoe_password ,
    }


    uri = URI("http://#{router_ip_address}/rest/user-manager/user/add")
    request = Net::HTTP::Post.new(uri)

    request.basic_auth router_username, router_password
    request.body = request_body.to_json
    request['Content-Type'] = 'application/json'



    response = Net::HTTP.start(uri.hostname, uri.port) do |http|
      http.request(request)
    end

    if response.is_a?(Net::HTTPSuccess)
      
      data = JSON.parse(response.body)
      return data['ret']


    else
      Rails.logger.info "Failed to  create subscriber: #{response.code} - #{response.message}"
    end


    


  end






  # DELETE /subscribers/1 or /subscribers/1.json
  def delete
  found_subscriber = set_subscriber
  # found_subscriber.destroy
  # head :no_content
  # 
  use_radius = ActsAsTenant.current_tenant.router_setting.use_radius
    
  unless found_subscriber
    return render json: { error: "Package not found" }, status: :not_found
  end


  if use_radius
    router_name = params[:router_name]
    nas_router = NasRouter.find_by(name: router_name)
  
    unless nas_router
      return render json: { error: "Router not found" }, status: :not_found
    end
  
    router_ip_address = nas_router.ip_address
    router_password = nas_router.password
      router_username = nas_router.username
  
    ppoe_secrets_id = found_subscriber.ppoe_secrets_id
    mikrotik_user_id = found_subscriber.mikrotik_user_id
  
    unless mikrotik_user_id.present?
      return render json: { error: "mikrotik_user_id id missing in package" }, status: :unprocessable_entity
    end 
  
    begin
      uri = URI("http://#{router_ip_address}/rest/user-manager/user/#{mikrotik_user_id}")
  
      request = Net::HTTP::Delete.new(uri)
  
      request.basic_auth(router_username, router_password)
  
      response = Net::HTTP.start(uri.hostname, uri.port, open_timeout: 10, read_timeout: 10) { |http| http.request(request) }
  
      if response.is_a?(Net::HTTPSuccess) 
  
        found_subscriber.destroy
        head :no_content
      else
        error_message = "Failed to delete usermanager user - #{response.code} #{response.message}"
        render json: { error: error_message }, status: :unprocessable_entity
      end
  
    rescue Net::OpenTimeout, Net::ReadTimeout
      render json: { error: "Request timed out while connecting to the router. Please check if the router is online." }, status: :gateway_timeout
    rescue Errno::ECONNREFUSED
      render json: { error: "Failed to connect to the router at #{router_ip_address}. Connection refused." }, status: :bad_gateway
    rescue StandardError => e
      render json: { error: "An unexpected error occurred: #{e.message}" }, status: :internal_server_error
    end
    
  else

  router_name = params[:router_name]
  nas_router = NasRouter.find_by(name: router_name)

  unless nas_router
    return render json: { error: "Router not found" }, status: :not_found
  end

  router_ip_address = nas_router.ip_address
  router_password = nas_router.password
  router_username = nas_router.username

  ppoe_secrets_id = found_subscriber.ppoe_secrets_id

  unless ppoe_secrets_id.present?
    return render json: { error: "secrets id missing in package" }, status: :unprocessable_entity
  end

  begin
    uri = URI("http://#{router_ip_address}/rest/ppp/secret/#{ppoe_secrets_id}")

    request = Net::HTTP::Delete.new(uri)

    request.basic_auth(router_username, router_password)

    response = Net::HTTP.start(uri.hostname, uri.port, open_timeout: 10, read_timeout: 10) { |http| http.request(request) }

    if response.is_a?(Net::HTTPSuccess) 

      found_subscriber.destroy
      head :no_content
    else
      error_message = "Failed to delete: Ppp  secrets - #{response.code} #{response.message}"
      render json: { error: error_message }, status: :unprocessable_entity
    end

  rescue Net::OpenTimeout, Net::ReadTimeout
    render json: { error: "Request timed out while connecting to the router. Please check if the router is online." }, status: :gateway_timeout
  rescue Errno::ECONNREFUSED
    render json: { error: "Failed to connect to the router at #{router_ip_address}. Connection refused." }, status: :bad_gateway
  rescue StandardError => e
    render json: { error: "An unexpected error occurred: #{e.message}" }, status: :internal_server_error
  end
  end



  end

  private




  def create_ppoe_us_and_pass_radcheck(ppoe_username, ppoe_password, package_name)
  
  
    ppoe_package = "pppoe_#{package_name.parameterize(separator: '_')}"
    
    RadCheck.create(username: ppoe_username, radiusattribute: 'Cleartext-Password', op: ':=', value: ppoe_password)  
    RadUserGroup.create(username: ppoe_username, groupname:  ppoe_package, priority: 1) 
    
    validity_period_units = Package.find_by(name: package_name).validity_period_units
    validity = Package.find_by(name: package_name).validity
    
    

    expiration_time = case validity_period_units
    when 'days' then Time.current + validity.days
    when 'hours' then Time.current + validity.hours
    when 'minutes' then Time.current + validity.minutes
    end&.strftime("%d %b %Y %H:%M:%S")
    
    if expiration_time
    
      rad_check = RadGroupCheck.find_or_initialize_by(groupname: ppoe_username, radiusattribute: 'Expiration')
      rad_check.update!(op: ':=', value: expiration_time)
    end
      
    
    
    
    end



    def calculate_expiration(package, ppoe_package_created)
      ppoe_package = Package.find_by(name: package)
    
      return render json: { error: 'Package not found' }, status: :not_found unless hotspot_package
      
      # Calculate expiration
      expiration_time = if ppoe_package.validity.present? && ppoe_package.validity_period_units.present?
        case ppoe_package.validity_period_units.downcase
        when 'days'
          Time.current + ppoe_package.validity.days
        when 'hours'
          Time.current + ppoe_package.validity.hours
        when 'minutes'
          Time.current + ppoe_package.validity.minutes
        else
          nil
        end
    
    
        
    
      # elsif hotspot_package.valid_until.present? && hotspot_package.valid_from.present?
      #   hotspot_package.valid_until
      else
        nil
      end
    
      # Update status only if expiration is present
      if expiration_time.present?
        ppoe_package_created.update(expiration: expiration_time&.strftime("%B %d, %Y at %I:%M %p"),)
      
      end
    
      # Return both expiration and status
      {
        expiration: expiration_time&.strftime("%B %d, %Y at %I:%M %p"),
      }
    end









        def subscriber_invalid(invalid)
          render json: {error: invalid.record.errors.full_messages}, status: :unprocessable_entity 
        end

        def subscriber_not_found_response
          render json: { error: "Subscriber Not Found" }, status: :not_found

        end


            def set_subscriber
              @subscriber = Subscriber.find_by(id: params[:id])
            end


            def subscriber_prefix_prefered_no_digits_params
              params.permit(:prefix, :minimum_digits)
              
            end


            def prefix_and_digits_params
              params.require(:prefix_and_digit).permit(:prefix, :minimum_digits)
            end
            # Only allow a list of trusted parameters through.
            def subscriber_params
              params.require(:subscriber).permit(:name, :phone_number, :ppoe_username, :ppoe_password,
              :house_number, :building_name, :latitude, :longitude,
               :email, :ppoe_package,
              :date_registered, :ref_no, :valid_until, :router_name, :package_name, :installation_fee, 
              :subscriber_discount, :second_phone_number)
            end


end

